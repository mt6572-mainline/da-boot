use da_patcher::{
    Disassembler, extract_imm,
    slice::fuzzy::{fuzzy_search_thumb2, generic_reg_matcher},
};
use da_protocol::Port;
use enum_dispatch::enum_dispatch;

pub mod croissant;
pub mod croissant2;
pub mod pumpkin;

use crate::{
    Result,
    exploit::{croissant::Croissant, croissant2::Croissant2, pumpkin::Pumpkin},
};

#[enum_dispatch]
pub trait Exploit {
    fn run(&self, port: &mut Port) -> Result<()>;
}

#[enum_dispatch(Exploit)]
pub enum Exploits<'a> {
    Croissant(Croissant<'a>),
    Croissant2(Croissant2<'a>),
    Pumpkin(Pumpkin<'a>),
}

impl<'a> Exploits<'a> {
    pub fn croissant(bytes: &'a [u8], payload: &'a [u8], payload_address: u32) -> Self {
        Self::Croissant(Croissant::new(bytes, payload, payload_address))
    }

    pub fn croissant2(bytes: &'a [u8], payload: &'a [u8], da1_base: u32) -> Self {
        Self::Croissant2(Croissant2::new(bytes, payload, da1_base))
    }

    pub fn pumpkin(da1: &'a [u8], da2: &'a [u8], payload: &'a [u8], da1_base: u32) -> Self {
        Self::Pumpkin(Pumpkin::new(da1, da2, payload, da1_base))
    }

    pub fn description(&self) -> &'static str {
        match self {
            Self::Croissant(_) => "Croissant (DA2)",
            Self::Croissant2(_) => "Croissant (DA1)",
            Self::Pumpkin(_) => "Pumpkin",
        }
    }
}

pub(super) fn croissant_find_ptr(
    pattern: &str,
    bytes: &[u8],
    pc_align: usize,
) -> Result<(u32, u32)> {
    let disasm = Disassembler::try_new()?;
    let ldr_offset = *fuzzy_search_thumb2(&disasm, bytes, pattern, generic_reg_matcher)?.start();
    let instructions = disasm.thumb2(&bytes[ldr_offset..ldr_offset + 4])?;
    let ldr = instructions
        .get(0)
        .ok_or(da_patcher::err::Error::PatternNotFound)?;
    // The actual ptr offset, e.g. #0x10
    let offset = extract_imm(
        ldr.op_str()
            .ok_or(da_patcher::err::Error::InstrOpNotAvailable)?,
    )? as u32;

    let start = ldr_offset - 0x50;
    let base_ldr_offset = start
        + *fuzzy_search_thumb2(
            &disasm,
            &bytes[start..ldr_offset],
            "ldr r?, [pc, #?]",
            generic_reg_matcher,
        )?
        .start();
    let instructions = disasm.thumb2(&bytes[base_ldr_offset..base_ldr_offset + 4])?;
    let ldr = instructions
        .get(0)
        .ok_or(da_patcher::err::Error::PatternNotFound)?;
    // The ldr is pc-relative, remember?
    let base_address_offset = extract_imm(
        ldr.op_str()
            .ok_or(da_patcher::err::Error::InstrOpNotAvailable)?,
    )?;
    let start = base_ldr_offset + pc_align + base_address_offset;
    let base_address = u32::from_le_bytes(bytes[start..start + 4].try_into()?);

    Ok((base_address, offset))
}
