use da_patcher::{
    Disassembler, extract_imm,
    slice::fuzzy::{fuzzy_search_thumb2, generic_reg_matcher},
};
use simpleport::Port;
use enum_dispatch::enum_dispatch;

pub mod croissant;
pub mod croissant2;
pub mod pumpkin;

use crate::{
    Result,
    exploit::{croissant::Croissant, croissant2::Croissant2, pumpkin::Pumpkin},
};

#[enum_dispatch]
pub trait Exploit {
    fn run(&self, port: &mut Port) -> Result<()>;
}

#[enum_dispatch(Exploit)]
pub enum Exploits<'a> {
    Croissant(Croissant<'a>),
    Croissant2(Croissant2<'a>),
    Pumpkin(Pumpkin<'a>),
}

impl<'a> Exploits<'a> {
    pub fn croissant(bytes: &'a [u8], payload: &'a [u8], payload_address: u32) -> Self {
        Self::Croissant(Croissant::new(bytes, payload, payload_address))
    }

    pub fn croissant2(bytes: &'a [u8], payload: &'a [u8], da1_base: u32) -> Self {
        Self::Croissant2(Croissant2::new(bytes, payload, da1_base))
    }

    pub fn pumpkin(da1: &'a [u8], da2: &'a [u8], payload: &'a [u8], da1_base: u32) -> Self {
        Self::Pumpkin(Pumpkin::new(da1, da2, payload, da1_base))
    }

    pub fn description(&self) -> &'static str {
        match self {
            Self::Croissant(_) => "Croissant (DA2)",
            Self::Croissant2(_) => "Croissant (DA1)",
            Self::Pumpkin(_) => "Pumpkin",
        }
    }
}

pub(super) fn croissant_find_ptr(
    pattern: &str,
    bytes: &[u8],
    pc_align: usize,
) -> Result<(u32, u32)> {
    let disasm = Disassembler::try_new()?;
    let ldr_offset = find(&disasm, bytes, pattern)? as usize;
    let instructions = disasm.thumb2(&bytes[ldr_offset..ldr_offset + 4])?;
    let ldr = instructions
        .get(0)
        .ok_or(da_patcher::err::Error::PatternNotFound)?;
    // The actual ptr offset, e.g. #0x10
    let offset = extract_imm(
        ldr.op_str()
            .ok_or(da_patcher::err::Error::InstrOpNotAvailable)?,
    )? as u32;

    let start = ldr_offset - 0x50;
    let base_ldr_offset =
        start + find(&disasm, &bytes[start..ldr_offset], "ldr r?, [pc, #?]")? as usize;
    let instructions = disasm.thumb2(&bytes[base_ldr_offset..base_ldr_offset + 4])?;
    let ldr = instructions
        .get(0)
        .ok_or(da_patcher::err::Error::PatternNotFound)?;
    // The ldr is pc-relative, remember?
    let base_address_offset = extract_imm(
        ldr.op_str()
            .ok_or(da_patcher::err::Error::InstrOpNotAvailable)?,
    )?;
    let start = base_ldr_offset + pc_align + base_address_offset;
    let base_address = u32::from_le_bytes(bytes[start..start + 4].try_into()?);

    Ok((base_address, offset))
}

pub(super) fn find(disasm: &Disassembler, bytes: &[u8], pattern: &str) -> Result<u32> {
    Ok(*fuzzy_search_thumb2(&disasm, bytes, pattern, generic_reg_matcher)?.start() as u32)
}

#[inline]
pub(super) fn cmp(disasm: &Disassembler, bytes: &[u8]) -> Result<u32> {
    find(disasm, bytes, "cmp r?, r?; beq #?; adr r?, #?; bl #?")
}

pub(super) fn boot_da2(disasm: &Disassembler, bytes: &[u8]) -> Result<u32> {
    find(
        disasm,
        bytes,
        "push.w ??; ldr r?, [pc, #?]; sub sp, #?; ldr r?, [r?, #?]; blx r?",
    )
}
